   <!--<link href='//fonts.googleapis.com/css?family=RobotoDraft:regular,bold,italic,thin,light,bolditalic,black,medium&lang=en' rel='stylesheet' type='text/css'>-->
<link rel="import" href="components/polymer/polymer.html">
<link rel="import" href="components/socket-io/socket-io.html">

<link rel="import" href="components/core-iconset-svg/core-iconset-svg.html">
<link rel="import" href="components/core-icons/core-icons.html">
<link rel="import" href="components/core-icons/device-icons.html">
<link rel="import" href="components/core-icons/hardware-icons.html">
<link rel="import" href="components/core-icons/image-icons.html">


<link rel="import" href="components/core-pages/core-pages.html">
<link rel="import" href="components/core-selector/core-selector.html">

<link rel="import" href="components/core-tooltip/core-tooltip.html">
<link rel="import" href="components/core-toolbar/core-toolbar.html">


<link rel="import" href="components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="components/paper-item/paper-item.html">
<link rel="import" href="components/paper-menu-button/paper-menu-button.html">
<link rel="import" href="components/paper-toast/paper-toast.html">

<link rel="import" href="components/paper-input/paper-input.html">
<link rel="import" href="components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="components/paper-tabs/paper-tabs.html">

<link rel="import" href="components/paper-dialog/paper-dialog-transition.html">
<link rel="import" href="components/paper-dialog/paper-dialog.html" >

<link rel="import" href="components/paper-dropdown/paper-dropdown.html">
<link rel="import" href="components/paper-slider/paper-slider.html">

<link rel="import" href="components/three-js/three-js.html">
<link rel="import" href="components/three-js-helpers/axis-helper.html">
<link rel="import" href="components/three-js-helpers/grid-helper.html">



<polymer-element name="simple-scan">
        <template>
            <link href="./simple-scan.css" rel="stylesheet" ></link>
            <core-toolbar >
              <paper-icon-button icon="menu"></paper-icon-button>
              <span flex>Simple-scan</span>
              <input type="button" on-tap="{{wsConnect}}" value="Test/debug" > </input>
              <span flex><template if="{{scanStarted}}">Scan in progress...</template></span>
              <span flex><template if="{{scanTime!=0}}">Scan took {{scanTime/60}} mins </template></span>

              <core-selector selected="2" id="menuItems">
                <core-tooltip label="Start scan">
                  <paper-icon-button icon="image:timelapse" on-tap="{{startScan}}" disabled?="{{scanStarted}}"></paper-icon-button>
                </core-tooltip>
                <core-tooltip label="Calibrate">
                  <paper-icon-button icon="image:auto-fix" on-tap="{{showCalibration}}" ></paper-icon-button>
                </core-tooltip>
                <core-tooltip label="Settings">
                  <paper-icon-button icon="settings"></paper-icon-button>
                </core-tooltip>
                <core-tooltip label="Save scan">
                  <paper-icon-button icon="file-download" disabled></paper-icon-button>
                </core-tooltip>
                <core-tooltip label="Connect to scanner">
                  <paper-icon-button icon="device:usb" disabled?="{{!serialConnected}}"></paper-icon-button>
                </core-tooltip>
              </core-selector>
              
              <paper-menu-button icon="more-vert" halign="right" valign="top">
                  <paper-item icon="drive-keep" label="Menu Item 1"></paper-item>
                  <paper-item icon="help"label="Help"></paper-item>
                  <paper-item icon="about"label="About"></paper-item>
              </paper-menu-button>

            </core-toolbar>

            <paper-dialog heading="Dialog" transition="paper-dialog-transition-center" id="foo">
              <paper-button label="More Info..." dismissive></paper-button>
              <paper-button label="Decline" affirmative></paper-button>
              <paper-button label="Accept" affirmative autofocus></paper-button>
            </paper-dialog>
            
            
             <three-js id="threeJs" unresolved>
                <three-stats id="stats" show></three-stats>
                <tween-js></tween-js>
                <three-js-scene name="main" active pickable>
                  <three-ambientLight color="0xffffff" intensity="3"> </three-ambientLight>
                </three-js-scene>
                <three-js-scene name="helper" active>
                    <axis-helper> </axis-helper>
                </three-js-scene>
                <three-js-viewport name="perspective" id="perspectiveView">
                  <three-js-combinedCamera pos="[200,200,100]" orientation="diagonal" up=[0,1,0]></three-js-combinedCamera>
                  <three-js-orbitControls cameraUp=[0,1,0] autoRotate="{{autoRotate}}" autoRotateSpeed="10"> </three-js-orbitControls>
                </three-js-viewport>
            </three-js>

            <core-pages selected="{{$.menuItems.selected}}" >
              <div id="scanning"></div>


              <div id="calibration"> 
                <h3>Calibration</h3>
                <div>
                  <paper-dropdown selected="{{calibView}}" >
                      <paper-item value="calibCam" label="camera"></paper-item>
                      <paper-item value="calibCamDebug" label="laser outline"></paper-item>
                  </paper-dropdown>
                </div>
                <div id="calibView" style="width:320px;height:240px;position:relative">
                  <core-pages selected="{{calibView-1}}" style="left:0px;right:0px;top:0px">
                    <canvas id="calibCam" width="320" height="240" style="position:absolute"></canvas>
                    <canvas id="calibCamDebug" width="320" height="240" style="position:absolute"></canvas>
                  </core-pages>
                  <div style="position:absolute;width:320px;height:240pxbackground:gray;"></div>
                </div>    
                <section id="calibControls" layout-horizontal center-justified>
                  
                  <div center horizontal layout>
                    <paper-icon-button fill id="doCalib" label="Calibrate" icon="image:auto-fix" on-tap="{{calibrate}}" disabled?="{{!connected}}"></paper-icon-button>
                    <div flex>Capture new image</div>
                    <paper-checkbox id="newCaptureToggler" class="blue" alt="newCaptureToggler" checked="{{calibNewCaptureToggled}}"></paper-checkbox>
                  </div>


                  <section>
                    <h4>Line detect</h4>
                      <div center horizontal layout class="control">
                        <div>Blur kernel</div><paper-slider value="15" max="30" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>Threshold</div><paper-slider value="{{scanner.vision.lineExtractionParams.threshold}}" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>Erosion</div><paper-slider value="{{scanner.vision.lineExtractionParams.erosion}}" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>Dilation</div><paper-slider value="{{scanner.vision.lineExtractionParams.dilation}}" max="100" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>OutThreshold</div><paper-slider value="{{scanner.vision.lineExtractionParams.outThreshold}}" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>MaxDist</div><paper-slider value="{{scanner.vision.lineExtractionParams.maxDist}}" max="255" editable></paper-slider>
                      </div>
                  </section>
                  <section>
                    <h4>Colors</h4>
                    <div>Hue </div>
                      <div center horizontal layout class="control red-slider">
                        <div>R</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control green-slider">
                        <div>G</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>B</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                    <div>Saturation </div>
                      <div center horizontal layout class="control red-slider">
                        <div>R</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control green-slider">
                        <div>G</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                      <div center horizontal layout class="control">
                        <div>B</div><paper-slider value="128" max="255" editable></paper-slider>
                      </div>
                   </section>
                </section>
              </div>



              <div id="settings">
                Serial
                <core-dropdown selected="1" >
                  <template repeat="{{port in serialPorts}}">
                    <core-item value="{{port.comName}}" label="{{port.comName}}"></core-item>
                  </template>
                </core-dropdown>

                Quality
                <paper-input  id="angleToQuality" floatingLabel label="angleQuality (lower == better)" type="number" error="Input is not a number!"
                  value={{scanQual}}
                    ></paper-input>  
                <paper-input  id="vertDpi" floatingLabel label="vertQuality (lower == better)" type="number" error="Input is not a number!"
                  value={{scanQualVert}}
                    ></paper-input>               

                <paper-checkbox id="debugToggler" class="blue" alt="debugToggler" checked="{{debugToggled}}"></paper-checkbox>
                <paper-checkbox id="colorsToggler" class="blue" alt="colorsToggler" checked="{{colorsToggled}}"></paper-checkbox>
                
                <input type="button" id="connect" value="connect" on-tap="{{connect}}"> </input>
                
                <section>
                  <h3>Laser</h3>
                  <div center horizontal layout>
                    <div flex>Toggle laser</div>
                    <paper-checkbox id="laserToggler" class="blue" alt="laserToggler" checked="{{laserToggled}}"></paper-checkbox>
                  </div>
                  <div center horizontal layout>
                    <div flex>Laser angle</div>
                    <paper-input disabled id="laserAngle" label="Laser angle" type="text"
                    value="{{laserAngle}}°"></paper-input> 
                  </div>
                  <div>
                    <paper-icon-button fill id="detectLaser" label="Detect laser" icon="image:auto-fix" on-tap="{{detectLaser}}" disabled?="{{!connected}}"></paper-icon-button>
                    <template if="{{laserDetected}}"> <div style="background:red">Laser Detected</div></template>
                  </div>
                </section>
                <section>
                  <h3>TurnTable</h3>
                  <div center horizontal layout>
                    <div flex>Toggle turnTable</div>
                    <paper-checkbox id="stepperToggler" class="blue" alt="stepperToggler" checked="{{stepperToggled}}"></paper-checkbox>
                  </div>
                  <div center horizontal layout>
                    <div >Rotate turnTable</div>
                    <div>
                    <paper-input id="angleToRotate"  floatingLabel label="rotation angle" type="number" error="Input is not a number!"
                    value={{angleToRotate}}
                    ></paper-input>    
                     <paper-input  id="stepsToRotate" floatingLabel label="rotation steps" type="number" error="Input is not a number!"
                  value={{stepsToRotate}}
                    ></paper-input>  
                    </div>
                  </div>
                  <div center horizontal layout>
                    <paper-icon-button fill id="rotateCCW" icon="rotate-left" on-tap="{{rotateCCW}}" disabled?="{{!stepperToggled}}"></paper-icon-button>
                    <paper-icon-button fill id="rotateCW" icon="rotate-right" on-tap="{{rotateCW}}" disabled?="{{!stepperToggled}}"></paper-icon-button>
                  </div>
              </section>

              <section>
                  <h3>Video</h3>
                  <div center horizontal layout>
                    Camera<select></select>
                  </div>

                  <div center horizontal layout>
                    <div flex>Toggle camera</div>
                    <paper-checkbox id="toggleCamera" class="blue" alt="cameraToggler" checked="{{cameraToggled}}"></paper-checkbox>
                  </div>


                  <div center horizontal layout>
                    <div flex>Camera feed</div>
                    <div>
                      <video id="video" width="640" height="480" autoplay></video>
                      <canvas id="videoCanvas" width="640" height="480"></canvas>
                      <!--<img id="img" src="./cam.png" alt="camera view"></img>-->
                    </div>
                    </div>
                  </div>


                  <div center horizontal layout>
                    Frame sending <input type="checkbox" id="frameToggler" alt="frameToggler" checked="{{sendFrames}}"></input>
                  </div>
              </section>   

              <section>
                <h3>Scanning</h3>
                <div center horizontal layout>
                  <paper-button label="Start Scan" icon="image:timelapse" on-tap="{{startScan}}"></paper-button>
                </div>
              </section>            
            </div>


            </core-pages>
            
            <paper-toast id="toast2" role="alert" text="Connection timed out. Showing limited messages." style="color:black;background: #4285f4;">
              <div style="color: #eeff41;" onclick="console.log('RETRY')">Retry</div>
            </paper-toast>

            <paper-toast id="toast" role="alert" text="{{userToastMessage}}" style="color:black;background: #4285f4;">
              <div style="color: #eeff41;" onclick="console.log('RETRY')">Retry</div>
            </paper-toast>
            <!--localhost:8082-->
            <socket-io id="socketIo" socketUrl="http://127.0.0.1:8082" listenTo=["laserDetected","scanFinished","status","userChanged","calibData","chunkStreamed"] inMessage={{inMessage}} outMessage={{outMessage}} outEventName={{outEventName}}>
             </socket-io>
        </template>
        <script>
            Polymer("simple-scan", {
                outEventName: "message",
                inMessage: "",
                outMessage: "",
                messages: [],
                clients: {},

                connected: false,

                serialConnected:false,
                serialPorts:[],
                sendFrames:false,
                //
                fps : 24,
                //
                laserToggled:false,
                laserDetected:false,
                stepperToggled:false,
                debugToggled  :false,
                //
                laserAngle:0,
                stepsToRotate:10,
                angleToRotate:10,
                _stepsPerRevo:400,//how many steps per full rotation

                scanQual:45,
                scanQualVert:2,
                scanData:null,
                pointCloud:null,
                scanTime:0,

                //
                calibView:null,

                //
                colorsToggled:false,
                //
                userToastMessage:"Disconnected from socket.io server!",

                //shadowing of "server side" structure
                scanner : null,

                observe:{ "scanner.vision.lineExtractionParams.dilation": "scannerChanged"},

                created:function(){
                  this.scanner= {
                    vision:{},
                    laser:{},
                    turnTable:{},
                    camera:{},
                    vision:{}
                  };

                  this.scanner.vision.lineExtractionParams = {
                     gaussBlurKernel : [15,15],
                     threshold       : 22,
                     erosion         : 2,
                     dilation        : 5,
                     outThreshold    : 250,
                     maxDist         : 40
                  };
       
                },
                attached:function(){
                  //listen to some events
                  this.$.socketIo.addEventListener('s-io-connected',    this.onSIOConnect.bind(this) );
                  this.$.socketIo.addEventListener('s-io-disconnected', this.onSIODisconnect.bind(this) );
                  this.$.socketIo.addEventListener('s-io-status',       this.onSIOStatus.bind(this) );
                  this.$.socketIo.addEventListener('s-io-laserDetected',this.onSIOlaserDetected.bind(this) );
                  this.$.socketIo.addEventListener('s-io-scanFinished' ,this.onSIOScanFinished.bind(this) );
                  this.$.socketIo.addEventListener('s-io-chunkStreamed',this.onSIOScanChunkStreamed.bind(this) );
                  this.$.socketIo.addEventListener('s-io-calibData'   ,this.onSIOCalibData.bind(this) );
                  
                },
                domReady:function(){
                  this.triDViewer = this.$.threeJs;

                  //draw Turntable
                  var radius   = 75,
                      segments = 64,
                      material = new THREE.LineBasicMaterial( { color: 0x000000 } ),
                      geometry = new THREE.CircleGeometry( radius, segments );
                  geometry.vertices.shift();
                  var turnTable = new THREE.Line( geometry, material );
                  turnTable.rotation.set(Math.PI/2,0,0)
                  this.triDViewer.addToScene( turnTable );


                  //connect websocket
                  this.$.socketIo.connect();
                },
                inMessageChanged:function(){
                    console.log("inMessage", this.inMessage);
                },
                sendMessage:function(cmd){
                    this.outMessage = cmd;
                },
                showToast:function(){
                  this.$.toast2.show();
                  this.$.foo.toggle();
                },
                //attribute change handlers
                propertyNameChanged:function(attrname){
                  console.log("attr changed",attrname);
                },
                scannerChanged:function(){

                  console.log("scanner changed");
                },
                laserToggledChanged:function()
                {
                    console.log("laser is", this.laserToggled);
                    this.sendMessage({event:"toggleLaser", data: this.laserToggled});
                },
                stepperToggledChanged:function()
                {
                    console.log("stepper is", this.stepperToggled);
                    this.sendMessage({event:"toggleStepper", data: this.stepperToggled});
                },
                stepsToRotateChanged:function(){
                    this.sendMessage({event:"stepsToRotate",data:this.stepsToRotate});
                    //update angle accordingly
                    var converted = this.stepsToRotate/this._stepsPerRevo*360; //stepsPerRevo == 360
                    if(converted != this.angleToRotate) this.angleToRotate = converted;
                },
                angleToRotateChanged:function(){
                    this.sendMessage({event:"angleToRotate",data:this.angleToRotate});
                    var converted = this.angleToRotate*this._stepsPerRevo/360; 
                    if(converted != this.stepsToRotate) this.stepsToRotate = converted;
                },
                colorsToggledChanged:function(){
                  //this.pointCloud.material = this.
                },
                calibViewChanged:function(){
                  console.log("calibView",this.calibView);
                  var calibView = this.calibView;
                },
                //event handlers
                onSIOConnect:function(){
                  this.connected = true;
                },
                onSIODisconnect:function(){
                  console.log("disconnected");
                  this.$.toast.show();
                },
                onSIOStatus:function(e, detail, sender){
                  console.log("recieved status event from socket io");
                  var status = e.detail.msg;
                  this.serialConnected = status.serialConnected;
                  this.laserToggled = status.laserOn;
                  this.stepperToggled = status.stepperOn;
                  this.serialPorts = status.serialPorts;

                  if(status.latestScan){
                    this.drawPointCloud( status.latestScan );
                  }
                },
                onSIOlaserDetected:function(e, detail, sender){
                  console.log("laser detected",e.detail.msg);
                  this.laserDetected=e.detail.msg.detected;
                },
                onSIOScanFinished:function(e,detail,sender){
                  console.log("scan finished",e.detail.msg.data);
                  this.scanStarted = false;

                  var scanEnd = new Date().getTime();
                  var scanTime = (Math.round(scanEnd-this._scanStart) / 1000);
                  console.log("scan took", scanTime,"seconds, ie", (scanTime/60), "minutes");
                  this.scanTime = scanTime;
                },
                onSIOScanChunkStreamed:function(e,detail,sender){
                  console.log("scan chunk rcv");
                  //TODO: user buffers, merge them, render
                  var scanData = e.detail.msg.data;
                  if(this.pointCloud) this.triDViewer.removeFromScene(this.pointCloud);
                
                  this.scanData.positions = this.scanData.positions.concat( scanData.positions );
                  this.scanData.colors    = this.scanData.colors.concat( scanData.colors );

                  var pos = this.scanData.positions;
                  var col = this.scanData.colors;

                  //generate
                  var points = this.scanData.positions.length/3;
                  var positions = new Float32Array( points* 3  ); 
	                var colors    = new Float32Array( points* 3  );

	                positions.set( pos );
	                colors.set( col );

                  var geometry = new THREE.BufferGeometry();
                  geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				          geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

                  //geometry.computeFaceNormals();
                  geometry.computeVertexNormals();
                  geometry.applyMatrix(new THREE.Matrix4().makeScale( 10, 10, 10 ) );


                  var material = new THREE.PointCloudMaterial({ size: 0.2,vertexColors: THREE.VertexColors});
                  var particles = new THREE.PointCloud( geometry, material );
                  
                  this.triDViewer.addToScene( particles );
                  this.pointCloud = particles;
                },
                onSIOCalibData:function(e,detail,sender){
                  var data = e.detail.msg;
                  console.log("calibration image recieved",data);

                  //draw main image with calibration lines
                  var canvas = this.$.calibCam ;
                  var ctx = canvas.getContext('2d');

                  var uint8Arr = new Uint8Array(data.lines);//.buffer);
                  var str = String.fromCharCode.apply(null, uint8Arr);
                  var base64String = btoa(str);

                  var img = new Image();
                  img.onload = function() {
                      var x = 0;
                      var y = 0;
                      ctx.drawImage(this, x, y);
                  }
                  img.src = 'data:image/png;base64,' + base64String;


                  //draw result image with debug outline
                  var canvas2 = this.$.calibCamDebug ;
                  var ctx2 = canvas2.getContext('2d');

                  var uint8Arr = new Uint8Array(data.debug);//.buffer);
                  var str = String.fromCharCode.apply(null, uint8Arr);
                  var base64String = btoa(str);

                  var img = new Image();
                  img.onload = function() {
                      var x = 0;
                      var y = 0;
                      ctx2.drawImage(this, x, y);
                  }
                  img.src = 'data:image/png;base64,' + base64String;

                },
                //internal api
                setupVideo:function(){
                  var self = this;
                   var video = self.$.video 
                   var canvas = self.$.videoCanvas;
                   var rotate = 180;
                   var zoom = 1;
                    self.canvas = canvas;
    
                   /*setInterval(function() {
                      self.$.img.src = "./cam.png"+"?time="+new Date().getTime();
                    }, 500);*/
                    navigator.getUserMedia = ( navigator.getUserMedia ||
                       navigator.webkitGetUserMedia ||
                       navigator.mozGetUserMedia ||
                       navigator.msGetUserMedia);

                    navigator.getUserMedia({ video: true, audio: false }, function(stream) {
                      video.src = window.URL.createObjectURL(stream);
                    }, function (err) { console.error(err); });

                    var ctx = self.$.videoCanvas.getContext('2d');

                    
                    mainTimer = setInterval(function () {

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.translate(canvas.width * 0.5, canvas.height * 0.5);
                    ctx.rotate(rotate * Math.PI / 180);
                    ctx.scale(zoom, zoom);
                    ctx.translate(-canvas.width * 0.5, -canvas.height * 0.5);
ctx.drawImage(video, 0, 0, 640, 480);
                    if(self.sendFrames)self.sendMessage({event:"frame", data: canvas.toDataURL("image/jpeg")});

                    });
                },

                drawPointCloud:function(data){
                  if(this.pointCloud) this.triDViewer.removeFromScene(this.pointCloud);

                  var pos = data.positions;
                  var col = data.colors;

                  //generate
                  var points = data.positions.length/3;
                  var positions = new Float32Array( points* 3  ); 
	                var colors    = new Float32Array( points* 3  );

	                positions.set( pos );
	                colors.set( col );

                  var geometry = new THREE.BufferGeometry();
                  geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				          geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

                  geometry.computeVertexNormals();
                  geometry.applyMatrix(new THREE.Matrix4().makeScale( 10, 10, 10 ) );


                  var material = new THREE.PointCloudMaterial({ size: 0.2,vertexColors: THREE.VertexColors});
                  var particles = new THREE.PointCloud( geometry, material );
                  
                  this.triDViewer.addToScene( particles );
                  this.pointCloud = particles;
                },
                //public api
                wsConnect:function(){
                console.log("attempting socket io connection");
                  this.$.socketIo.connect();
                },
                connect:function(){
                  this.sendMessage({event:"connectToScanner",data:null});
                  //TODO: should be based on confirmation from server
                  this.serialConnected = true;
                },
                rotateCW:function()
                {
                    this.sendMessage({event:"rotate", data: {direction:"CW",degrees:parseInt(this.angleToRotate)}});
                },
                rotateCCW:function()
                {
                    this.sendMessage({event:"rotate", data: {direction:"CCW",degrees:-parseInt(this.angleToRotate)}});
                },
                startScan:function()
                {
                    console.log("starting Scan");
                    this.sendMessage({event:"scan", data:{debug:this.debugToggled,stepDegrees:this.scanQual,vDpi:this.scanQualVert}});
                    this.scanStarted=true;
                    this.scanData = {positions:[],colors:[]};
                    this._scanStart = new Date().getTime();
                    this.scanTime = 0;
                },
                detectLaser:function(){
                    console.log("detectLaser");
                    this.sendMessage({event:"detectLaser",data:{debug:this.debugToggled}});//data: canvas.toDataURL("image/jpeg")
                    this.laserDetected=false;
                },
                calibrate:function(){
                  console.log("starting calibration");
                  this.sendMessage({event:"calibrate", data:{doCapture:this.calibNewCaptureToggled, options: this.scanner.vision.lineExtractionParams , debug:this.debugToggled}});
                  this.calibrationStarted=true;
                }
            });
        </script>
     </polymer-element>
